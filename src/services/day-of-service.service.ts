// Model
import DayOfServiceModel from '@src/models/day-of-service.model'
import FootballFieldModel from '@src/models/football-field.model'

// Constants
import EnvVars from '@src/constants/EnvVars'
import {
  TDayOfService,
  TFootballField,
  TTurnOfService,
  TurnOfServiceStatus,
} from '@src/types' // TODO

// Utilities
import {
  getAutoGenerateDate,
  getExpireDate,
  getNextWeek,
} from '@src/util/timestep'
import {
  checkTurnOfServiceStatus,
  getListTurnOfServices,
  updateTurnOfServices,
} from '@src/util/turn-of-service'
import { Types } from 'mongoose'

// BUG Fix the response data. It's too large and included some unnecessary date
export function getById(id: string) {
  return DayOfServiceModel.findById(id).select({
    __v: 0,
    expireAt: 0,
    'turnOfServices.bookingId': 0,
  })
}

// BUG Fix the response data. It's too large and included some unnecessary date
export function getByFieldId(id: Types.ObjectId) {
  return DayOfServiceModel.find(
    {
      fieldId: id,
      availability: true,
      'turnOfServices.status': { $eq: TurnOfServiceStatus.AVAILABLE },
    },
    { __v: 0, turnOfServices: 0 },
    { limit: 30 },
  )
}

// BUG Fix the response data. It's too large and included some unnecessary date
export function getBySubFieldId(id: Types.ObjectId) {
  return DayOfServiceModel.find(
    { subfieldId: id, availability: true },
    { __v: 0, turnOfServices: 0 },
    { limit: 30 },
  )
}

// BUG Fix the response data. It's too large and included some unnecessary date
/**
 * Query list of `day of service`
 * @description by default will query from `current time` to `next week`
 * @param from start of time range
 * @param to end of time range
 * @param fieldIds list of field to search from
 * @returns list of `day of service`
 */
export function getMany(
  from: Date = new Date(),
  to: Date = getNextWeek(from),
  fieldIds?: string[],
) {
  /**
   * If fieldIds provided then query `$in` the fieldIds list
   */
  const query = fieldIds
    ? {
        fieldId: { $in: fieldIds },
        date: { $gte: from, $lte: to },
        availability: true,
        'turnOfServices.status': { $eq: TurnOfServiceStatus.IN_PROGRESS },
      }
    : {
        date: { $gte: from, $lte: to },
        availability: true,
        'turnOfServices.status': { $eq: TurnOfServiceStatus.IN_PROGRESS },
      }
  return DayOfServiceModel.find(
    query,
    { __v: 0, 'turnOfServices.bookingId': 0, expireAt: 0 },
    { limit: 50 },
  )
}

export function generateOnCreate(
  fieldId: Types.ObjectId,
  subfieldId: Types.ObjectId,
  defaultPrice: number,
  fieldOpenTime: string,
  fieldCloseTime: string,
) {
  const turnOfServices = getListTurnOfServices(
    fieldOpenTime,
    fieldCloseTime,
    defaultPrice,
  )

  if (!turnOfServices) return null

  const tomorrow = new Date()
  tomorrow.setDate(tomorrow.getDate() + 1)
  tomorrow.setUTCHours(0, 0, 0, 0)

  const dates: Array<
    Omit<TDayOfService, '_id' | 'availability' | 'turnOfServices'> & {
      turnOfServices: Partial<TTurnOfService>[]
    }
  > = Array.from(
    { length: EnvVars.Rules.DayOfService.rangeDays - 1 }, // start from tomorrow to range day
    (_, i) => i,
  ).map((value) => {
    const date = new Date(tomorrow.getTime() + value * 24 * 60 * 60 * 1000) // 1 day
    return {
      fieldId: fieldId,
      subfieldId: subfieldId,
      date: date,
      expireAt: getExpireDate(date),
      turnOfServices: turnOfServices,
    }
  })

  return DayOfServiceModel.insertMany(dates)
}

export async function autoGenerate() {
  const generateDate = getAutoGenerateDate()
  const existed = await DayOfServiceModel.findOne({ date: generateDate })

  if (existed)
    throw new Error(
      `Day of services at ${generateDate.toISOString()} already exists`,
    )

  const fields = (await FootballFieldModel.find()
    .select('_id subfieldIds openedAt closedAt')
    .populate('subfields', '_id defaultPrice availability')) as Pick<
    TFootballField,
    '_id' | 'subfields' | 'closedAt' | 'openedAt'
  >[]

  if (!fields) return

  try {
    fields.forEach((field) => {
      // populated subfields
      if (!field.subfields.length) return

      field.subfields.forEach(async (subfield) => {
        const found = await DayOfServiceModel.findOne({
          date: generateDate,
          subfieldId: subfield._id,
        })

        if (found) return // if already found

        // generate day of service
        await DayOfServiceModel.create({
          fieldId: field._id,
          subfieldId: subfield._id,
          date: generateDate,
          expireAt: getExpireDate(generateDate),
          turnOfServices: getListTurnOfServices(
            field.openedAt,
            field.closedAt,
            subfield.defaultPrice,
          ),
        })
      })
    })
  } catch (err) {
    throw new Error(
      'Auto generate DayOfService ERROR: ' + (err as Error).message,
    )
  }
}

/**
 * Update Day of Service (not including turns of service)
 */
export async function updateOne(id: string, data: Partial<TDayOfService>) {
  // check if trying to update turns of service
  if (data.turnOfServices) {
    const found = await DayOfServiceModel.findById(id)
    if (!found) return null

    const newTurnOfService = updateTurnOfServices(
      found.turnOfServices,
      data.turnOfServices,
    )

    return DayOfServiceModel.findByIdAndUpdate(id, {
      turnOfServices: newTurnOfService,
    })
  }

  return DayOfServiceModel.findByIdAndUpdate(id, data)
}

export async function checkValidUpdate(
  date: Date,
  subfieldId: string,
  from: string,
  to: string,
  status: TurnOfServiceStatus,
) {
  const found = await DayOfServiceModel.findOne({
    date: date,
    subfieldId: subfieldId,
  }).exec()

  if (!found) return false

  return checkTurnOfServiceStatus(found.turnOfServices, from, to, status)
}

export function addBookingId(
  bookingId: string | null,
  subfieldId: string,
  date: Date,
  from: string,
  to: string,
  status: TurnOfServiceStatus,
) {
  return DayOfServiceModel.updateOne(
    { subfieldId: subfieldId, date: date },
    {
      $set: {
        'turnOfServices.$[ele].status': status,
        'turnOfServices.$[ele].bookingId': bookingId,
      },
    },
    {
      arrayFilters: [{ 'ele.at': { $gte: from, $lt: to } }],
    },
  )
}

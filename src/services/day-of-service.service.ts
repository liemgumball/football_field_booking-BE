// Model
import DayOfServiceModel from '@src/models/day-of-service.model'
import * as LocationService from '@src/services/location.service'

// Constants
import EnvVars from '@src/constants/EnvVars'
import {
  TDayOfService,
  TSubField,
  TTurnOfService,
  TurnOfServiceStatus,
} from '@src/types'

// Utilities
import { getAutoGenerateDate, getTomorrow } from '@src/util/date'
import {
  checkTurnOfServiceStatus,
  getListTurnOfServices,
  updateTurnOfServices,
} from '@src/util/turn-of-service'
import { ClientSession, Types } from 'mongoose'
import { getDateList } from '@src/util/date'
import SubFieldModel from '@src/models/subfield.model'

// FIXME Fix the response data. It's too large and included some unnecessary date
export function getById(id: string) {
  return DayOfServiceModel.findById(id).select({
    __v: 0,
    expireAt: 0,
    'turnOfServices.bookingId': 0,
  })
}

// FIXME Fix the response data. It's too large and included some unnecessary date
export function getByFieldId(id: Types.ObjectId) {
  return DayOfServiceModel.find(
    {
      fieldId: id,
      availability: true,
      'turnOfServices.status': { $eq: TurnOfServiceStatus.AVAILABLE },
    },
    { __v: 0, turnOfServices: 0 },
    { limit: 30 },
  )
}

// FIXME Fix the response data. It's too large and included some unnecessary date
export function getBySubFieldId(id: Types.ObjectId) {
  return DayOfServiceModel.find(
    { subfieldId: id, availability: true },
    { __v: 0, turnOfServices: 0 },
    { limit: 30 },
  )
}

// FIXME Fix the response data. It's too large and included some unnecessary date
/**
 * Query list of `day of service`
 * @description by default will query from `current time` to `next week`
 * @param from start of time range
 * @param to end of time range
 * @returns list of `day of service`
 */
export async function getManyAvailable(
  date: Date,
  latitude?: string,
  longitude?: string,
  distance?: number,
  from?: string,
  to?: string,
) {
  /**
   * If fieldIds provided then query `$in` the fieldIds list
   */
  let fieldIds = null

  if (longitude && latitude)
    fieldIds = await LocationService.getFieldIdNearFromLocation(
      [+longitude, +latitude],
      distance,
    )

  const query = fieldIds
    ? {
        fieldId: { $in: fieldIds },
        date: date,
        availability: true,
        turnOfServices: {
          $elemMatch: {
            at: { $gte: from, $lt: to ? to : '24:00' },
            status: TurnOfServiceStatus.AVAILABLE,
          },
        },
      }
    : {
        date: date,
        availability: true,
        turnOfServices: {
          $elemMatch: {
            at: { $gte: from, $lt: to ? to : '24:00' },
            status: TurnOfServiceStatus.AVAILABLE,
          },
        },
      }

  return DayOfServiceModel.find(
    query,
    { __v: 0, 'turnOfServices.bookingId': 0, expireAt: 0 },
    { limit: 50 },
  )
    .populate('field', {
      name: 1,
      rating: 1,
      images: 1,
    })
    .populate('subfield', {
      name: 1,
      size: 1,
    })
}

export function generateOnCreate(
  fieldId: Types.ObjectId,
  subfieldId: Types.ObjectId,
  defaultPrice: number,
  fieldOpenTime: string,
  fieldCloseTime: string,
  session?: ClientSession,
) {
  const turnOfServices = getListTurnOfServices(
    fieldOpenTime,
    fieldCloseTime,
    defaultPrice,
  )

  if (!turnOfServices) return null

  const tomorrow = getTomorrow()

  const dates: Array<
    Omit<
      TDayOfService,
      '_id' | 'availability' | 'turnOfServices' | 'expireAt'
    > & {
      turnOfServices: Partial<TTurnOfService>[]
    }
  > = Array.from(
    { length: EnvVars.Rules.DayOfService.rangeDays - 1 }, // start from tomorrow to range day
    (_, i) => i,
  ).map((value) => {
    const date = new Date(tomorrow.getTime() + value * 24 * 60 * 60 * 1000) // 1 day
    return {
      fieldId: fieldId,
      subfieldId: subfieldId,
      date: date,
      turnOfServices: turnOfServices,
    }
  })

  return DayOfServiceModel.insertMany(dates, { session })
}

export async function autoGenerate() {
  const generateDate = getAutoGenerateDate()
  const existed = await DayOfServiceModel.findOne({ date: generateDate })

  if (existed)
    throw new Error(
      `Day of services at ${generateDate.toISOString()} already exists`,
    )

  const subfields = (await SubFieldModel.find().populate('field', {
    openedAt: 1,
    closedAt: 1,
  })) as TSubField[]

  if (!subfields) return

  try {
    subfields.forEach(async (subfield) => {
      // get latest data based on subfield
      const found = await DayOfServiceModel.findOne(
        {
          subfieldId: subfield._id,
        },
        {},
        { sort: { date: -1 } },
      )

      if (found && found.date >= generateDate) return // if already exists

      // generate day of service
      await DayOfServiceModel.insertMany(
        getDateList(found?.date || new Date(), generateDate).map((item) => ({
          fieldId: subfield.fieldId,
          subfieldId: subfield._id,
          date: item,
          turnOfServices: getListTurnOfServices(
            subfield.field!.openedAt,
            subfield.field!.closedAt,
            subfield.defaultPrice,
          ),
        })),
      )
    })
  } catch (err) {
    throw new Error(
      'Auto generate DayOfService ERROR: ' + (err as Error).message,
    )
  }
}

/**
 * Update Day of Service (not including turns of service)
 */
export async function updateOne(id: string, data: Partial<TDayOfService>) {
  // check if trying to update turns of service
  if (data.turnOfServices) {
    const found = await DayOfServiceModel.findById(id)
    if (!found) return null

    const newTurnOfService = updateTurnOfServices(
      found.turnOfServices,
      data.turnOfServices,
    )

    return DayOfServiceModel.findByIdAndUpdate(id, {
      turnOfServices: newTurnOfService,
    })
  }

  return DayOfServiceModel.findByIdAndUpdate(id, data)
}

export async function checkValidUpdate(
  date: Date,
  subfieldId: string,
  from: string,
  to: string,
  status: TurnOfServiceStatus,
) {
  const found = await DayOfServiceModel.findOne({
    date: date,
    subfieldId: subfieldId,
  }).exec()

  if (!found) return false

  return checkTurnOfServiceStatus(found.turnOfServices, from, to, status)
}

export function addBookingId(
  bookingId: string | null,
  subfieldId: string,
  date: Date,
  from: string,
  to: string,
  status: TurnOfServiceStatus,
) {
  return DayOfServiceModel.updateOne(
    { subfieldId: subfieldId, date: date },
    {
      $set: {
        'turnOfServices.$[ele].status': status,
        'turnOfServices.$[ele].bookingId': bookingId,
      },
    },
    {
      arrayFilters: [{ 'ele.at': { $gte: from, $lt: to } }],
    },
  )
}
